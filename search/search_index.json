{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KubeNSync operator","text":"<p>Introducing KubeNSync, a Kubernetes operator designed to simplify the creation of repetitive resources within distinct namespaces (but also cluster wide!). Craft resource templates tailored to your needs, and with the flexibility of a namespace selector, effortlessly synchronize chosen resources. Streamline resource management and enhance deployment efficiency using KubeNSync's intuitive approach.</p>"},{"location":"#description","title":"Description","text":"<p>KubeNSync is a Kubernetes operator that helps you automate the creation of Kubernetes resources. You can use it to create resources like pull secrets, RBAC rules, and operators using Go templates. With KubeNSync, you can define a Custom Resource (CR) that contains the template to be rendered and a namespace selector in the form of a regex. This allows you to create and manage resources in specific namespaces or across the entire cluster.</p>"},{"location":"examples/","title":"Examples","text":"<p>KubeNSync can simplify cluster management by creating custom resources tailored to specific scenarios. Here are a couple of examples of how to use KubeNSync to manage different resources:</p>"},{"location":"examples/#creating-a-serviceaccount-in-all-test-namespaces","title":"Creating a ServiceAccount in All Test Namespaces","text":"<p><pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\nname: serviceaccount-sample\nspec:\nnamespaceSelector:\nregex: \"test\"\ntemplate:\nliteral: |\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: managed-resource-sa\nnamespace: {{ .Namespace.Name }}\n</code></pre> This MR will create a Service Account <code>managed-resource-sa</code> in each namespace that contains <code>test</code> in its name.</p>"},{"location":"examples/#creating-a-pull-secret-in-all-development-namespaces","title":"Creating a Pull Secret in All Development Namespaces","text":"<p><pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\nname: pullsecret-sample\nspec:\nnamespaceSelector:\nregex: \"^dev-.*\"\ntemplate:\nliteral: |\n---\napiVersion: v1\nkind: Secret\nmetadata:\nname: my-pull-secret\nnamespace: {{ .Namespace.Name }}\ntype: kubernetes.io/dockerconfigjson\ndata:\n.dockerconfigjson: &lt;your pull secret in base64&gt;\n</code></pre> This MR will create a Secret <code>my-pull-secret</code> in each namespace that contains <code>dev-</code> in its name that contains the credentials to connect to your internal registry.</p> <p>Tip</p> <p>References to a valid dockerconfigjson secret to avoid duplicies and having plain secrets can be also used (an recommended!):</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\nname: pullsecret-sample\nspec:\nnamespaceSelector:\nregex: \"^dev-.*\"\ntemplate:\ndata:\n- name: pull_secret\ntype: Secret\nref:\nname: my-pull-secret\nnamespace: default\nliteral: |\n---\napiVersion: v1\nkind: Secret\nmetadata:\nname: my-pull-secret\nnamespace: {{ .Namespace.Name }}\ntype: kubernetes.io/dockerconfigjson\ndata:\n.dockerconfigjson: '{{ index .Data.pull_secret \".dockerconfigjson\" | b64enc }}'\n</code></pre>"},{"location":"examples/#setting-up-rbac-rules-in-specific-namespaces","title":"Setting Up RBAC Rules in Specific Namespaces","text":"<p><pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\nname: rbac-sample\nspec:\nnamespaceSelector:\nregex: \"^(namespace1|namespace2)$\"\ntemplate:\nliteral: |\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: my-role\nnamespace: {{ .Namespace.Name }}\nrules:\n- apiGroups: [\"\"]\nresources: [\"pods\"]\nverbs: [\"get\", \"list\", \"watch\"]\n</code></pre> This MR will create a Role <code>my-role</code> in each namespace that contains <code>namespace1</code> o <code>namespace2</code> in its name that contains the credentials to connect to your internal registry.</p>"},{"location":"examples/#create-default-quotas-on-all-non-core-namespaces","title":"Create default quotas on all non core namespaces","text":"<pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\nname: default-quotas\nspec:\navoidResourceUpdate: true\nnamespaceSelector:\nregex: \"^[^k].*|k[^u].*|ku[^b].*\" # (1)!\ntemplate:\nliteral: |\n---\napiVersion: v1\nkind: ResourceQuota\nmetadata:\nname: cpu-quota\nnamespace: {{ .Namespace.Name }}\nspec:\nhard:\ncpu: \"4\"\n</code></pre> <ol> <li> <p>Warning</p> As Go regex stdlib does not support negative lookaheads the negative expressions is a bit funny. It would be <code>^(?!kube-).*</code>, meaning everything that does not start by <code>kube-</code>. </li> </ol> <p>This MR will create a ResourceQuota <code>cpu-quota</code> in each namespace that not start with <code>kube-</code> with cpu hard value of <code>4</code>, but it will not be resynced unless it's deleted, so the quota can be edited by other means and it won't be restored to the default <code>4</code>. </p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before deploying the kubensync operator, ensure you have the following prerequisites:</p> <ul> <li>Kubernetes cluster up and running.</li> <li><code>kubectl</code> CLI tool configured to access your cluster.</li> <li><code>cluster-admin</code> privileges.</li> <li>Operator Lifecycle Manager (OLM) installed if you want to use the OLM installation method.</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Default SA permissions</p> <p>After installing the operator, the operator service account does not have permissions to create resources by default. Therefore, you need to define and grant the necessary permissions manually. This allows you to specify the minimum permission level required for the operator to create objects.</p> <p>The reason for this is that the template is rendered at runtime, so it is not possible to determine the required permissions for each specific scenario before installing the operator.</p>"},{"location":"getting-started/#using-operator-lifecycle-manager-olm","title":"Using Operator Lifecycle Manager (OLM)","text":"<ol> <li>Import the catalog source:     <pre><code>kubectl apply -f https://raw.githubusercontent.com/eryalito/operator-catalog/main/samples/catalogsource.yml\n</code></pre></li> <li>Install the <code>kubensync</code> operator using olm.</li> </ol>"},{"location":"getting-started/#using-kubectl-kustomize","title":"Using kubectl / kustomize","text":"<ol> <li>Clone this repo:     <pre><code>git clone https://github.com/eryalito/kubensync-operator.git\n</code></pre></li> <li>Change the working directory:     <pre><code>cd kubensync-operator\n</code></pre></li> <li>Deploy the operator and its resources:     <pre><code>kubectl apply -k deploy/\n</code></pre></li> </ol>"},{"location":"getting-started/#uninstallation","title":"Uninstallation","text":""},{"location":"getting-started/#using-operator-lifecycle-manager-olm_1","title":"Using Operator Lifecycle Manager (OLM)","text":"<ol> <li>Open the olm in your cluster.</li> <li>Find the kubensync operator and click \"Uninstall.\"</li> </ol>"},{"location":"getting-started/#using-kubectl-kustomize_1","title":"Using kubectl / kustomize","text":"<ol> <li>Change the working directory:     <pre><code>cd kubensync-operator\n</code></pre></li> <li>Delete the kubensync resources:     <pre><code>kubectl delete -k deploy/\n</code></pre></li> </ol>"},{"location":"usage/","title":"Usage","text":"<p>Once the kubensync operator is installed, you can start using it by defining custom resources (CRs) that specify the resources you want to synchronize.</p>"},{"location":"usage/#managedresource","title":"ManagedResource","text":"<p>The ManagedResource kind allows users to define a template to apply for each selected namespace. </p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\nname: managedresource-sample\nspec:\navoidResourceUpdate: false\nnamespaceSelector:\nregex: \"test\"\ntemplate:\ndata: # (1)!\n- name: pull_secret # (2)!\ntype: Secret\nref:\nname: my-pull-secret\nnamespace: default\nliteral: |\n---\napiVersion: v1\nkind: Secret\nmetadata:\nname: my-pull-secret\nnamespace: {{ .Namespace.Name }}\ntype: kubernetes.io/dockerconfigjson\ndata:\n.dockerconfigjson: '{{ index .Data.pull_secret \".dockerconfigjson\" | b64enc }}'\n</code></pre> <ol> <li> <p>Tip</p> You can read as many secrets or configmaps as you need, even if they are duplicates. Just keep in mind that name should be unique. </li> <li> <p>Info</p> <p>This will be the value used on the template</p> </li> </ol> <p>Question</p> <ul> <li><code>avoidResourceUpdate</code>: Optional field that changes the default behavior of reconciling existing resources with the desired state. If set to true only non-existing resources will be created an never updated. Default values is <code>false</code>.</li> <li><code>namespaceSelector</code>: Specifies the namespaces where you want to apply the template. You can use a regular expression (regex) to match multiple namespaces.</li> <li><code>template</code>: Contains the YAML template that you want to apply to the selected namespaces. You can use Go template syntax to customize the resource based on the namespace.</li> <li><code>template.data</code>: Optional field that read <code>Secret</code> or <code>ConfigMap</code> and imports the contents to be used in the <code>template</code> under <code>.Data.&lt;name&gt;</code>.</li> </ul>"}]}