{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KubeNSync","text":"<p>KubeNSync is a Kubernetes operator designed to simplify resource management across namespaces and the entire cluster. Say goodbye to repetitive resource creation and hello to efficient deployment with KubeNSync!</p>"},{"location":"#what-is-kubensync","title":"What is KubeNSync?","text":"<p>KubeNSync automate the creation of Kubernetes resources using custom templates and namespace selectors. It allows to define a template for a resource and automatically apply it to multiple namespaces, ensuring consistency and reducing manual effort.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Namespace Selector: Use regex or label selectors to target specific namespaces.</li> <li>Custom Resource Templates: Define reusable templates for Kubernetes resources.</li> <li>Data Injection: Inject data from existing resources into your templates.</li> <li>Cluster-Wide Synchronization: Automatically synchronize resources to maintain the desired state.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to dive in? Follow these steps to get started with KubeNSync:</p> <ol> <li> <p>Install the Operator    Deploy KubeNSync to your cluster using <code>kubectl</code>:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/eryalito/kubensync-operator/master/dist/install.yaml\n</code></pre> </li> <li> <p>Grant Permissions    Apply the default RBAC configuration:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/eryalito/kubensync-operator/master/dist/rbac.yaml\n</code></pre> </li> </ol>"},{"location":"#documentation","title":"Documentation","text":"<p>Explore the documentation to learn more:</p> <ul> <li>Get Started</li> <li>Usage</li> <li>Reference</li> <li>Examples</li> </ul>"},{"location":"examples/","title":"Examples Overview","text":"<p>This is a collection of examples demonstrating the usage of <code>kubensync</code> in various scenarios. The examples are organized by use case and provide a basic implementation:</p> <ul> <li>Service Account</li> <li>Pull Secret</li> <li>RBAC</li> <li>ConfigMap</li> </ul>"},{"location":"examples/pull-secret/","title":"Creating a Pull Secret in All Development Namespaces","text":""},{"location":"examples/pull-secret/#use-case","title":"Use case","text":"<p>Automatic creation of a pull secret in all development namespaces. This is useful for setting up a pull secret on a per-namespace basis, especially in a multi-tenant environment, where each environment may require different credentials to access a private container registry.</p>"},{"location":"examples/pull-secret/#implementation","title":"Implementation","text":"<p>This ManagedResource (MR) will clone a pull secret from the default namespace to all namespaces that contain <code>dev-</code> in their name.</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: pullsecret-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        data:\n        - name: pull_secret\n            type: Secret\n            ref:\n                name: my-pull-secret\n                namespace: default\n        literal: |\n            ---\n            apiVersion: v1\n            kind: Secret\n            metadata:\n                name: my-pull-secret\n                namespace: {{ .Namespace.Name }}\n            type: kubernetes.io/dockerconfigjson\n            data:\n                .dockerconfigjson: '{{ index .Data.pull_secret \".dockerconfigjson\" | b64enc }}'\n</code></pre>"},{"location":"examples/quota/","title":"Creating a ResourceQuota in All Non-Core Namespaces","text":""},{"location":"examples/quota/#use-case","title":"Use case","text":"<p>To avoid overconsumption of resources in a Kubernetes cluster, it is important to set up resource quotas in all namespace in non-core namespaces. When having a multi-tenant cluster, it is important to set up resource quotas in all namespaces, specially on non-production ones.</p>"},{"location":"examples/quota/#implementation","title":"Implementation","text":"<p>This ManagedResource (MR) will create a ResourceQuota <code>default-quota</code> in each namespace that does not start with <code>kube</code>, <code>kub</code>, or <code>k</code> (core namespaces).</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: default-quota\nspec:\n    avoidResourceUpdate: true\n    namespaceSelector:\n        regex: \"^[^k].*|k[^u].*|ku[^b].*\" # (1)!\n    template:\n        literal: |\n            ---\n            apiVersion: v1\n            kind: ResourceQuota\n            metadata:\n                name: cpu-quota\n                namespace: {{ .Namespace.Name }}\n            spec:\n                hard:\n                    cpu: \"4\"\n</code></pre> <ol> <li> <p>Warning</p> As Go regex stdlib does not support negative lookaheads the negative expressions is a bit funny. It would be <code>^(?!kube-).*</code>. </li> </ol>"},{"location":"examples/rbac-handling/","title":"Setting up RBAC permissions","text":""},{"location":"examples/rbac-handling/#use-case","title":"Use case","text":"<p>Automatic RBAC permissions applied to namespaces to give users access to specific resources. This is useful for setting up permissions in a multi-tenant environment where different teams or users need access to different resources.</p>"},{"location":"examples/rbac-handling/#implementation","title":"Implementation","text":"<p>This ManagedResource (MR) will create a Role <code>my-role</code> in each namespace that contains <code>dev-</code> in its name. The role will allow the user to get, list, and watch pods.</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: rbac-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        literal: |\n            ---\n            apiVersion: rbac.authorization.k8s.io/v1\n            kind: Role\n            metadata:\n                name: my-role\n                namespace: {{ .Namespace.Name }}\n            rules:\n                - apiGroups: [\"\"]\n                  resources: [\"pods\"]\n                  verbs: [\"get\", \"list\", \"watch\"]\n</code></pre> <p>This can be extended to create a RoleBinding to bind the role to a user or group. For example, to bind the role to a user named <code>my-user</code>, you can use the following MR:</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: rbac-binding-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        literal: |\n            ---\n            apiVersion: rbac.authorization.k8s.io/v1\n            kind: RoleBinding\n            metadata:\n                name: my-role-binding\n                namespace: {{ .Namespace.Name }}\n            subjects:\n                - kind: User\n                  name: my-user\n                  apiGroup: rbac.authorization.k8s.io\n            roleRef:\n                kind: Role\n                name: my-role\n                apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"examples/service-account/","title":"Creating a ServiceAccount in All Test Namespaces","text":""},{"location":"examples/service-account/#use-case","title":"Use case","text":"<p>A specific Service Account is required in all test namespaces. This is need to run test jobs in a CI/CD pipeline and the default SA is not allowed.</p>"},{"location":"examples/service-account/#implementation","title":"Implementation","text":"<p>This ManagedResource (MR) will create a Service Account <code>managed-resource-sa</code> in each namespace that contains <code>test</code> in its name.</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: serviceaccount-sample\nspec:\n    namespaceSelector:\n        regex: \"test\"\n    template:\n        literal: |\n            ---\n            apiVersion: v1\n            kind: ServiceAccount\n            metadata:\n                name: managed-resource-sa\n                namespace: {{ .Namespace.Name }}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before deploying the kubensync operator, ensure you have the following prerequisites:</p> <ul> <li>Kubernetes cluster up and running.</li> <li><code>kubectl</code> CLI tool configured to access your cluster.</li> <li><code>cluster-admin</code> privileges.</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Default SA permissions</p> <p>After installing the operator, the operator service account does not have permissions to create resources by default. Therefore, you need to define and grant the necessary permissions manually. This allows you to specify the minimum permission level required for the operator to create objects.</p> <p>The reason for this is that the template is rendered at runtime, so it is not possible to determine the required permissions for each specific scenario before installing the operator.</p>"},{"location":"getting-started/#using-kubectl-kustomize","title":"Using kubectl / kustomize","text":"<ol> <li>Install the operator:     <pre><code>kubectl apply -f https://raw.githubusercontent.com/eryalito/kubensync-operator/master/dist/install.yaml\n</code></pre></li> <li> <p>Grant Permissions:      <pre><code>kubectl apply -f https://raw.githubusercontent.com/eryalito/kubensync-operator/master/dist/rbac.yaml\n</code></pre></p> <p>Warning</p> <p>This permissions will grant the operator cluster-admin permissions. It's a good way of testing the operator, but specific permissions should be defined acording to the resources it will manage in each specific case.</p> </li> </ol>"},{"location":"getting-started/#uninstallation","title":"Uninstallation","text":""},{"location":"getting-started/#using-kubectl-kustomize_1","title":"Using kubectl / kustomize","text":"<ol> <li>Delete the operator:     <pre><code>kubectl delete -f https://raw.githubusercontent.com/eryalito/kubensync-operator/master/dist/install.yaml\n</code></pre></li> <li>Delete Permissions:      <pre><code>kubectl delete -f https://raw.githubusercontent.com/eryalito/kubensync-operator/master/dist/rbac.yaml\n</code></pre></li> </ol>"},{"location":"reference/","title":"Reference Overview","text":"<p>In this section, you will find detailed information about sections, fields, and types of the ManagedResource kind. This is a comprehensive reference guide to help you understand the structure and usage of the ManagedResource kind in KubeNSync.</p> <ul> <li>Selectors</li> <li>Template</li> <li>Template Functions</li> <li>Template Data</li> </ul>"},{"location":"reference/selectors/","title":"Namespace Selector","text":"<p>Namespaces can be selected using a regex or a label selector. The regex is applied to the namespace name, while the label selector is applied to the namespace labels. The regex and label selector are combined using an AND operation.</p>"},{"location":"reference/selectors/#regex","title":"Regex","text":"<p>The regex is applied to the namespace name. The regex is applied directly to the namespace name, so it looks for matches in the namespace name itself. For example, the regex <code>test</code> will match any namespace that contains the string <code>test</code> in its name, such as <code>test</code>, <code>test-1</code>, or <code>my-test-namespace</code>.</p> <p>The regex is a standard Go regex, so you can use any valid Go regex syntax. For example, the regex <code>^test-.*</code> will match any namespace that starts with <code>test-</code>, such as <code>test-1</code>, <code>test-2</code>, or <code>test-abc</code>.</p> <p>Tip</p> <p>As the regex is matching anything in the namespace name, it is recommended to use a regex that is as specific as possible. For example, if you want to match only namespaces that start with <code>test-</code>, you should use the regex <code>^test-.*</code> instead of just <code>test</code>. This will help avoid matching unintended namespaces.</p>"},{"location":"reference/selectors/#label-selector","title":"Label Selector","text":"<p>The label selector is applied to the namespace labels. The label selector is a standard Kubernetes label selector. For example, the label selector <code>environment=production</code> will match any namespace that has the label <code>environment</code> set to <code>production</code>.</p>"},{"location":"reference/selectors/#example","title":"Example","text":"<p>Selecting all namespaces that start with <code>shopping-</code> and have the label <code>environment=production</code>:</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    avoidResourceUpdate: false\n    namespaceSelector:\n        regex: \"^shopping-.*\"\n        labelSelector:\n            matchLabels:\n                environment: production\n    template:\n        # ...\n        # Additional YAML configuration goes here\n        # ...\n</code></pre>"},{"location":"reference/template-data/","title":"Template Data","text":"<p>Kubernetes objects can be accessed in the template using the <code>.Data</code> field. The <code>.spec.template.data</code> field contains a list of the resources that are loaded and processed by the template engine. The resources must be present in the Kubernetes cluster and must be accessible to the kubensync operator. The resources are loaded and processed in the order they are defined.</p>"},{"location":"reference/template-data/#data-field","title":"Data Field","text":"<p>The data resources are defined in the <code>spec.template.data</code> field. Each resource must have a unique name. The type can be one of the following:</p> <ul> <li><code>Secret</code>: A Kubernetes Secret resource.</li> <li><code>ConfigMap</code>: A Kubernetes ConfigMap resource.</li> <li><code>KubernetesResource</code>: A Kubernetes resource of any kind.</li> </ul> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        data:\n        - name: my_secret\n          type: Secret\n          ref:\n            name: my-secret\n            namespace: default\n        - name: my_configmap\n          type: ConfigMap\n          ref:\n            name: my-configmap\n            namespace: default\n        - name: my_resource\n          type: KubernetesResource\n          ref:\n            apiVersion: v1\n            group: \"\"\n            kind: ServiceAccount\n            name: test\n            namespace: default\n        literal: |\n            # Continue...\n</code></pre>"},{"location":"reference/template-data/#secret","title":"Secret","text":"<p>The <code>Secret</code> type is used to load a Kubernetes Secret resource. The <code>ref</code> field must contain only the name and namespace of the Secret resource. The Secret resource is loaded and processed, so the keys and values of the Secret are available in the template using the <code>.Data.&lt;name&gt;</code> syntax. The values are automatically base64 decoded, so no additional processing is needed.</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        data:\n        - name: my_secret\n          type: Secret\n          ref:\n            name: my-secret\n            namespace: default\n        literal: |\n            ---\n            apiVersion: v1\n            kind: Secret\n            metadata:\n                name: my-secret\n                namespace: {{ .Namespace.Name }}\n            type: Opaque\n            data:\n                key1: {{ index .Data.my_secret \"key1\" | b64enc }}\n                key2: {{ index .Data.my_secret \"key2\" | b64enc }}\n</code></pre>"},{"location":"reference/template-data/#configmap","title":"ConfigMap","text":"<p>The <code>ConfigMap</code> type is used to load a Kubernetes ConfigMap resource. The <code>ref</code> field must contain only the name and namespace of the ConfigMap resource. The ConfigMap resource is loaded and processed, so the keys and values of the ConfigMap are available in the template using the <code>.Data.&lt;name&gt;</code> syntax.</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        data:\n        - name: my_configmap\n          type: ConfigMap\n          ref:\n            name: my-configmap\n            namespace: default\n        literal: |\n            ---\n            apiVersion: v1\n            kind: ConfigMap\n            metadata:\n                name: my-configmap\n                namespace: {{ .Namespace.Name }}\n            data:\n                key1: {{ index .Data.my_configmap \"key1\" }}\n                key2: {{ index .Data.my_configmap \"key2\" }}\n</code></pre>"},{"location":"reference/template-data/#kubernetesresource","title":"KubernetesResource","text":"<p>The <code>KubernetesResource</code> type is used to load a Kubernetes resource of any kind. The <code>ref</code> field must contain the full resource definition, including the <code>apiVersion</code>, <code>group</code>, <code>kind</code>, and <code>name</code>. The resource is loaded but not processed. This means that the raw object parse into a map is available in the template using the <code>.Data.&lt;name&gt;</code> syntax.</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    namespaceSelector:\n        regex: \"^dev-.*\"\n    template:\n        data:\n        - name: my_resource\n          type: KubernetesResource\n          ref:\n            apiVersion: v1\n            group: \"\"\n            kind: ServiceAccount\n            name: test\n            namespace: default\n        literal: |\n            ---\n            apiVersion: v1\n            kind: ConfigMap\n            metadata:\n                name: my-cm\n                namespace: {{ .Namespace.Name }}\n            data:\n                serviceAccountName: '{{ .Data.my_resource.metadata.name }}'\n</code></pre> <p>Tip</p> <p>The ServiceAccount name is loaded from <code>.Data.my_resource.metadata.name</code> as the raw kubernetes object is loaded and not processed.</p>"},{"location":"reference/template-functions/","title":"Template Functions","text":"<p>The template engine used by kubensync is based on the Go template engine. It contains the default functions provided by the Go template engine, as well as some additional functions.</p>"},{"location":"reference/template-functions/#default-functions","title":"Default Functions","text":"<p>The default functions provided by the Go template engine are available in the template context. A highlight of the most commonly used functions is provided below. For a complete list of functions, see the Go template documentation.</p> <ul> <li><code>len</code>: Returns the length of a string, array, slice, or map.</li> <li><code>index</code>: Returns the element at the specified index in an array, slice, or map.</li> <li><code>slice</code>: Returns a slice of the specified array or slice.</li> <li><code>printf</code>: Formats a string using the specified format and arguments.</li> </ul>"},{"location":"reference/template-functions/#additional-functions","title":"Additional Functions","text":"<p>Sprout is included in the template engine. This library provides a set of additional functions that can be used to manipulate strings, arrays, maps and objects.</p> <p>Highlighted functions include:</p> <ul> <li><code>base64Encode</code>: Encodes a string in base64.</li> <li><code>base64Decode</code>: Decodes a base64 encoded string.</li> <li><code>fromYAML</code>: Converts a YAML string to a map.</li> <li><code>toYAML</code>: Converts a map to a YAML string.</li> <li><code>trim</code>: Trims whitespace from a string.</li> <li><code>join</code>: Joins a list of strings into a single string using the specified separator.</li> <li><code>split</code>: Splits a string into a list of strings using the specified separator.</li> <li><code>indent</code>: Indents a string by the specified number of spaces.</li> </ul> <p>Info</p> <p>Full list of functions can be found in the Sprout documentation.</p>"},{"location":"reference/template/","title":"Template","text":"<p>The templating engine used by kubensync is based on the Go template engine. It allows you to create dynamic configurations by using placeholders and functions directly integrated in the engine.</p> <p>The Go template must be provided in the <code>spec.template.literal</code> field and the output after rendering must be a list of valid YAML files that can be applied to the Kubernetes cluster, separated by <code>---</code>. The template engine will process the placeholders and functions, and generate the final YAML output.</p> <p>Custom data can be passed to the template using the <code>data</code> field. The data is a list of resources that will be injected into the template <code>.Data</code> field. The data can be any valid Kubernetes resource, such as a ConfigMap or a Secret. The data is passed to the template as a map under the <code>.Data</code> field. The key of the map is the name provided. The resource can be referenced in the template using the <code>{{ .Data.&lt;name&gt; }}</code> syntax.</p> <p>The template engine also provides a set of functions that can be used to manipulate the data. The functions are available in the template context and can be used to perform operations such as encoding, decoding, and formatting the data.</p> <p>Info</p> <p>The template engine is based on the Go template engine, so you can use any valid Go template syntax. For more information about the Go template syntax, see the Go template documentation.</p>"},{"location":"reference/template/#example","title":"Example","text":"<p>Loading and processing a secret and using it in the template:</p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    avoidResourceUpdate: false\n    namespaceSelector:\n        regex: \"test\"\n    template:\n        data:\n        - name: pull_secret\n          type: Secret\n          ref:\n            name: my-pull-secret\n            namespace: default\n        literal: |\n            ---\n            apiVersion: v1\n            kind: Secret\n            metadata:\n                name: my-pull-secret\n                namespace: {{ .Namespace.Name }}\n            type: kubernetes.io/dockerconfigjson\n            data:\n                .dockerconfigjson: '{{ index .Data.pull_secret \".dockerconfigjson\" | b64enc }}'\n            ---\n            # Other resources can be added here\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Once the kubensync operator is installed, you can start using it by defining custom resources (CRs) that specify the resources you want to synchronize.</p>"},{"location":"usage/#managedresource","title":"ManagedResource","text":"<p>The ManagedResource kind allows users to define a template to apply for each selected namespace. </p> <pre><code>apiVersion: automation.kubensync.com/v1alpha1\nkind: ManagedResource\nmetadata:\n    name: managedresource-sample\nspec:\n    avoidResourceUpdate: false\n    namespaceSelector:\n        regex: \"test\"\n        labelSelector: # (3)!\n          matchLabels: {} # (4)!\n          matchExpressions: {} # (5)!\n    template:\n        data: # (1)!\n        - name: pull_secret # (2)!\n          type: Secret\n          ref:\n            name: my-pull-secret\n            namespace: default\n        literal: |\n            ---\n            apiVersion: v1\n            kind: Secret\n            metadata:\n                name: my-pull-secret\n                namespace: {{ .Namespace.Name }}\n            type: kubernetes.io/dockerconfigjson\n            data:\n                .dockerconfigjson: '{{ index .Data.pull_secret \".dockerconfigjson\" | b64enc }}'\n</code></pre> <ol> <li> <p>Tip</p> You can read as many secrets or configmaps as you need, even if they are duplicates. Just keep in mind that name should be unique. </li> <li> <p>Info</p> <p>This will be the value used on the template</p> </li> <li> <p>Info</p> <p>Select namespaces based on labels.</p> </li> <li> <p>Info</p> <pre><code>DESCRIPTION:\nmatchLabels is a map of {key,value} pairs. A single {key,value} in the\nmatchLabels map is equivalent to an element of matchExpressions, whose key\nfield is \"key\", the operator is \"In\", and the values array contains only\n\"value\". The requirements are ANDed.\n</code></pre> </li> <li> <p>Info</p> <pre><code>DESCRIPTION:\nmatchExpressions is a list of label selector requirements. The requirements\nare ANDed.\n\nA label selector requirement is a selector that contains values, a key, and\nan operator that relates the key and values.\n\nFIELDS:\nkey  &lt;string&gt; -required-\n  key is the label key that the selector applies to.\n\noperator     &lt;string&gt; -required-\n  operator represents a key's relationship to a set of values. Valid\n  operators are In, NotIn, Exists and DoesNotExist.\n\nvalues       &lt;[]string&gt;\n  values is an array of string values. If the operator is In or NotIn, the\n  values array must be non-empty. If the operator is Exists or DoesNotExist,\n  the values array must be empty. This array is replaced during a strategic\n  merge patch.\n</code></pre> </li> </ol> <p>Question</p> <ul> <li><code>avoidResourceUpdate</code>: Optional field that changes the default behavior of reconciling existing resources with the desired state. If set to true only non-existing resources will be created an never updated. Default values is <code>false</code>.</li> <li><code>namespaceSelector</code>: Specifies the namespaces where you want to apply the template. You can use a regular expression (regex) to match multiple namespaces or filter them by its labels. Regex and labels are ANDed, the namespaces must match both of them to be selected. If none of them are defined, all namespaces will be selected.</li> <li><code>template</code>: Contains the YAML template that you want to apply to the selected namespaces. You can use Go template syntax to customize the resource based on the namespace.</li> <li><code>template.data</code>: Optional field that read Kubernetes resources and expose their contents to be used in the <code>template</code> under <code>.Data.&lt;name&gt;</code>.</li> </ul>"},{"location":"usage/#examples","title":"Examples","text":"<p>Check out some real-world use cases of kubensync in the examples section. Here are some examples of how to use the <code>ManagedResource</code> kind:</p>"},{"location":"versions/v0.8.0/","title":"Version v0.8.0","text":"<p>This is the documentation for version 0.8.0 of the project.</p>"},{"location":"versions/v0.8.0/#new-features","title":"New Features","text":"<ul> <li>Add <code>mr</code> as shortname for ManagedResources.</li> </ul>"},{"location":"versions/v0.8.0/#changes","title":"Changes","text":"<ul> <li>Developer mode is now deactivated by default. To enable it add the argument <code>-zap-devel=true</code>.</li> </ul>"},{"location":"versions/v0.8.0/#breaking-changes","title":"Breaking Changes","text":"<ul> <li> <p>Sprig functions are no longer available in the template in favor the Sprout functions.</p> <p>Tip</p> <p>All default sprig registries are enabled and available in the template. Most of the changed functions are just renamed to sprout functions. Check of the Migration Guide for more details.</p> </li> </ul>"}]}